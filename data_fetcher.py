# -*- coding: utf-8 -*-
"""Usprawniony Data Fetcher z Cache

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/130A5Kd3Qqefe_NYIk1CgHUI09SVncnoi
"""

# -*- coding: utf-8 -*-
"""
Moduł do komunikacji z API Alpha Vantage.

Odpowiedzialność: Bezpieczne i wydajne pobieranie danych giełdowych,
z uwzględnieniem limitów API, buforowaniem wyników oraz transformacją
danych do użytecznego formatu.
"""
import requests
import os
import time
from collections import deque
import pandas as pd
from typing import Dict, Optional, Union

def transform_to_dataframe(data: Dict, data_key: str = "Time Series (Daily)") -> Optional[pd.DataFrame]:
    """
    Transformuje odpowiedź JSON z Alpha Vantage do pandas.DataFrame.

    Args:
        data (Dict): Surowa odpowiedź JSON z API.
        data_key (str): Klucz w JSON, pod którym znajdują się dane szeregu czasowego.

    Returns:
        Optional[pd.DataFrame]: DataFrame z danymi lub None w przypadku błędu.
    """
    if not data or data_key not in data:
        print(f"Błąd transformacji: Brak klucza '{data_key}' w odpowiedzi API.")
        return None
    try:
        df = pd.DataFrame.from_dict(data[data_key], orient='index')
        df.index = pd.to_datetime(df.index)
        # Konwersja z usunięciem błędów - bardziej odporne
        df = df.apply(pd.to_numeric, errors='coerce')
        # Zmiana nazw kolumn, aby były bardziej czytelne
        df.rename(columns={
            '1. open': 'open',
            '2. high': 'high',
            '3. low': 'low',
            '4. close': 'close',
            '5. volume': 'volume'
        }, inplace=True)
        # Sortowanie od najstarszych do najnowszych dat
        df.sort_index(ascending=True, inplace=True)
        return df
    except Exception as e:
        print(f"Wystąpił błąd podczas konwersji danych do DataFrame: {e}")
        return None

class DataFetcher:
    def __init__(self, api_key: str):
        if not api_key:
            raise ValueError("Klucz API jest wymagany.")
        self.api_key = api_key
        self.base_url = "https://www.alphavantage.co/query"
        self.api_call_timestamps = deque()
        # Zgodnie z wymaganiami - 75 zapytań na minutę
        self.requests_per_minute = 75
        # NAPRAWIONO: Dodano mechanizm cache zgodny z dokumentacją
        self.cache = {}
        self.cache_lifetime_seconds = 4 * 60 * 60  # 4 godziny

    def _is_cache_valid(self, cache_entry: Dict) -> bool:
        """Sprawdza, czy wpis w cache jest jeszcze ważny."""
        return (time.time() - cache_entry['timestamp']) < self.cache_lifetime_seconds

    def _wait_if_needed(self):
        """Inteligentnie zarządza częstotliwością zapytań, aby nie przekroczyć limitu."""
        now = time.time()
        # Usuń znaczniki czasu starsze niż minuta
        while self.api_call_timestamps and self.api_call_timestamps[0] <= now - 60:
            self.api_call_timestamps.popleft()

        if len(self.api_call_timestamps) >= self.requests_per_minute:
            time_to_wait = 60 - (now - self.api_call_timestamps[0]) + 1
            print(f"INFO: Osiągnięto limit API. Czekam {time_to_wait:.2f}s...")
            time.sleep(time_to_wait)

    def get_data(self, params: dict, response_format: str = 'json') -> Optional[Union[Dict, str]]:
        """
        Wykonuje zapytanie do API Alpha Vantage z obsługą cache i różnych formatów.
        """
        # NAPRAWIONO: Logika sprawdzania i zwracania danych z cache
        cache_key = tuple(sorted(params.items()))
        if cache_key in self.cache and self._is_cache_valid(self.cache[cache_key]):
            print(f"INFO: Zwracam dane z cache dla funkcji: {params.get('function', 'N/A')}, symbol: {params.get('symbol', 'N/A')}")
            return self.cache[cache_key]['data']

        self._wait_if_needed()
        all_params = {"apikey": self.api_key, **params}

        log_function = params.get('function', 'N/A')
        log_symbol = params.get('symbol', 'N/A')
        print(f"INFO: Wykonuję zapytanie do API dla funkcji: {log_function}, symbol: {log_symbol}")

        try:
            response = requests.get(self.base_url, params=all_params)
            response.raise_for_status()
            self.api_call_timestamps.append(time.time())

            # NAPRAWIONO: Obsługa różnych formatów odpowiedzi
            if response_format == 'csv':
                result = response.text
                if "Error Message" in result: # Proste sprawdzenie błędu w CSV
                     print(f"BŁĄD: Otrzymano błąd z API (CSV): {result}")
                     return None
            else:
                result = response.json()
                if "Error Message" in result:
                    print(f"BŁĄD: Otrzymano błąd z API: {result['Error Message']}")
                    return None
                if "Information" in result:
                    print(f"INFO: Otrzymano informację z API: {result['Information']}")
                    return None

            # Zapis do cache po pomyślnym pobraniu
            self.cache[cache_key] = {'timestamp': time.time(), 'data': result}
            return result

        except requests.exceptions.RequestException as e:
            print(f"BŁĄD: Błąd sieciowy podczas komunikacji z API: {e}")
            return None
        except ValueError:
            print("BŁĄD: Nie udało się zdekodować odpowiedzi JSON z API.")
            return None

if __name__ == "__main__":
    API_KEY = os.getenv("ALPHA_VANTAGE_API_KEY", "TWOJ_KLUCZ_API")
    if API_KEY == "TWOJ_KLUCZ_API":
        print("OSTRZEŻENIE: Używasz domyślnego klucza API. Ustaw zmienną środowiskową ALPHA_VANTAGE_API_KEY.")

    fetcher = DataFetcher(api_key=API_KEY)

    print("\n--- Test 1: Pobieranie danych OVERVIEW dla AAPL (pierwsze zapytanie) ---")
    fetcher.get_data({"function": "OVERVIEW", "symbol": "AAPL"})
    print("\n--- Test 2: Pobieranie danych OVERVIEW dla AAPL (powinno być z cache) ---")
    aapl_overview = fetcher.get_data({"function": "OVERVIEW", "symbol": "AAPL"})
    if aapl_overview:
        print(f"Pobrano dane dla: {aapl_overview.get('Name')}")

    print("\n--- Test 3: Pobieranie danych CSV (LISTING_STATUS) ---")
    listing_csv = fetcher.get_data({"function": "LISTING_STATUS"}, response_format='csv')
    if listing_csv and isinstance(listing_csv, str):
        print(f"Pobrano dane CSV, długość: {len(listing_csv)} znaków.")
        print("Pierwsze 100 znaków:", listing_csv[:100])
    else:
        print("Nie udało się pobrać danych CSV.")