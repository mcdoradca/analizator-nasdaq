# -*- coding: utf-8 -*-
"""Naprawiony Agent Szybkiej Ligi

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1w1PUOQavejsNvwPuukJQ5YsXzFBv74EI
"""

"""
Moduł Zespołu Taktycznego AI ("Szybka Liga").

Odpowiedzialność: Skanowanie spółek z "Dream Teamu" w poszukiwaniu
krótkoterminowych, precyzyjnych okazji transakcyjnych opartych na strategii
"Łowcy Impulsu i Korekty".
"""
from utils import safe_float, get_latest_value

# --- Agent Korekty Fibonacciego ---

def agent_korekty_fibonacciego(daily_data, period=30):
    """
    Identyfikuje spółki po silnym impulsie wzrostowym, które dokonują
    zdrowej korekty do kluczowych poziomów zniesienia Fibonacciego.
    """
    try:
        if not daily_data or 'Time Series (Daily)' not in daily_data: return {}
        series = list(daily_data['Time Series (Daily)'].items())[:period]
        if len(series) < 15: return {} # Wymagamy minimum 15 dni danych

        prices = [(s[0], {k.replace('. ', ''): safe_float(v) for k, v in s[1].items()}) for s in series]

        # Znajdź lokalny dołek i szczyt ostatniego impulsu
        highs = [p[1].get('2high', 0) for p in prices]
        if not highs: return {}
        recent_high = max(highs)
        high_date_index = highs.index(recent_high)

        # NAPRAWIONO: Szukamy dołka, który poprzedzał szczyt, a nie następował po nim.
        # To jest kluczowa zmiana w logice strategii.
        lows_before_high = [p[1].get('3low', 0) for p in prices[high_date_index:]]
        if not lows_before_high: return {}
        recent_low = min(lows_before_high)

        current_price = prices[0][1].get('4close', 0)

        # Walidacja, czy znalezione wartości są sensowne
        if recent_low == 0 or recent_high == 0 or current_price == 0: return {}
        if current_price >= recent_high: return {}

        price_range = recent_high - recent_low
        if price_range == 0: return {}

        # Oblicz poziomy Fibonacciego
        fibo_382 = recent_high - 0.382 * price_range
        fibo_500 = recent_high - 0.500 * price_range
        fibo_618 = recent_high - 0.618 * price_range

        if fibo_500 <= current_price <= fibo_382:
            return {
                'signal': 'Korekta do strefy Fibonacciego',
                'entry': current_price,
                'plan': {
                    'target': recent_high,
                    'stopLoss': fibo_618
                }
            }
        return {}
    except (ValueError, IndexError, KeyError) as e:
        print(f"[Agent Fibonacciego] Błąd analizy: {e}")
        return {}

# --- Agenci Pomocniczy ---

def agent_potwierdzenia(rsi_data, stoch_data):
    """Sprawdza, czy rynek nie jest wykupiony (RSI, Stoch)."""
    try:
        if not rsi_data or not stoch_data: return 0
        rsi = safe_float(get_latest_value(rsi_data, 'Technical Analysis: RSI', 'RSI'))
        stoch = safe_float(get_latest_value(stoch_data, 'Technical Analysis: STOCH', 'SlowK'))
        if rsi > 75 or stoch > 85: return 0
        return 1
    except Exception:
        return 0

def agent_historyczny(daily_data):
    """Weryfikuje, czy spółka ma historię dynamicznych wzrostów wewnątrzsesyjnych."""
    stats = {'1.5': 0, '2.0': 0, '3.0': 0}
    try:
        if not daily_data or 'Time Series (Daily)' not in daily_data: return {'historyScore': 0, 'stats': stats}
        series = list(daily_data['Time Series (Daily)'].values())[:90]
        for day in series:
            op = safe_float(day.get('1. open'))
            hi = safe_float(day.get('2. high'))
            if op == 0: continue

            intraday_change = ((hi / op) - 1) * 100
            if intraday_change >= 3.0: stats['3.0'] += 1
            if intraday_change >= 2.0: stats['2.0'] += 1
            if intraday_change >= 1.5: stats['1.5'] += 1

        history_score = 1 if stats['2.0'] >= 5 else 0
        return {'historyScore': history_score, 'stats': stats}
    except Exception:
        return {'historyScore': 0, 'stats': stats}

# --- Główna Funkcja Orkiestrująca Skanowanie ---

def run_quick_league_scan(dream_team_tickers, data_fetcher):
    """
    Orkiestruje pracę wszystkich agentów Szybkiej Ligi, aby wyłonić okazje.
    """
    opportunities = []
    print(f"[Szybka Liga] Rozpoczynam skanowanie {len(dream_team_tickers)} spółek...")

    for ticker in dream_team_tickers:
        try:
            daily_data = data_fetcher.get_data({"function": "TIME_SERIES_DAILY", "symbol": ticker, "outputsize": "compact"})
            rsi_data = data_fetcher.get_data({"function": "RSI", "symbol": ticker, "interval": "daily", "time_period": 14, "series_type": "close"})
            stoch_data = data_fetcher.get_data({"function": "STOCH", "symbol": ticker, "interval": "daily"})

            if not all([daily_data, rsi_data, stoch_data]):
                continue

            signal_result = agent_korekty_fibonacciego(daily_data)

            if signal_result.get('signal'):
                confirmation_score = agent_potwierdzenia(rsi_data, stoch_data)
                history_result = agent_historyczny(daily_data)
                total_score = 1 + confirmation_score + history_result['historyScore']

                plan = signal_result.get('plan', {})
                entry_price = signal_result.get('entry')
                stop_loss = plan.get('stopLoss')
                target = plan.get('target')

                if not all([entry_price, stop_loss, target]): continue

                risk = entry_price - stop_loss
                reward = target - entry_price

                if risk <= 0 or reward <= 0 or reward / risk < 1.5:
                    continue

                opportunities.append({
                    'ticker': ticker,
                    'signal': signal_result['signal'],
                    'plan': plan,
                    'stats': history_result['stats'],
                    'score': total_score
                })
        except Exception as e:
            print(f"[Szybka Liga] Błąd podczas analizy {ticker}: {e}")
            continue

    print(f"[Szybka Liga] Skanowanie zakończone. Znaleziono {len(opportunities)} okazji.")
    return opportunities