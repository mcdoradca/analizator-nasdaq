# -*- coding: utf-8 -*-
"""Finalna Wersja main.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vpDl8YPkxGqqrOZ_A_j-93T1lUToK_S2
"""

# main.py
# Główny plik "silnika" aplikacji. Uruchamia serwer API i łączy wszystkich agentów.

import os
import uvicorn
import pandas_ta as ta
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Dict, Any, Optional

# --- NAPRAWIONO: Poprawiono importy i dodano brakujące moduły ---
from data_fetcher import DataFetcher, transform_to_dataframe
from portfolio_manager import PortfolioManager
from selection_agent import run_market_scan
# Poprawiono nazwę funkcji z `run_golden_league_analysis` na `run_zlota_liga_analysis`
from zlota_liga_agent import run_zlota_liga_analysis
from szybka_liga_agent import run_quick_league_scan
from backtesting_agent import run_backtest
from macro_agent import get_macro_climate_analysis, get_market_barometer
from cockpit_agent import analyze_cockpit_data
# Dodano import agenta ryzyka portfela
from risk_agent import analyze_single_stock_risk, run_portfolio_risk_analysis

# --- Struktury Danych (Modele Pydantic) ---
class PositionPayload(BaseModel):
    ticker: str
    quantity: int
    entryPrice: float
    targetPrice: float
    stopLossPrice: float
    reason: Optional[str] = None

class ClosePositionPayload(BaseModel):
    id: str
    closePrice: float

# --- Inicjalizacja Aplikacji i Kluczowych Komponentów ---
app = FastAPI(title="Analizator Nasdaq API", version="3.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], # W produkcji warto ograniczyć do konkretnej domeny
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

api_key = os.getenv("ALPHA_VANTAGE_API_KEY")
if not api_key:
    raise RuntimeError("Brak klucza API! Ustaw zmienną środowiskową ALPHA_VANTAGE_API_KEY.")

data_fetcher = DataFetcher(api_key=api_key)
portfolio_manager = PortfolioManager()

# --- Endpointy API ---

@app.get("/")
def read_root():
    return {"status": "API Analizatora Nasdaq działa poprawnie."}

# --- Agenci Makro ---
@app.get("/api/macro_climate", response_model=Dict)
async def api_get_macro_climate():
    return get_macro_climate_analysis(data_fetcher)

@app.get("/api/market_barometer", response_model=Dict)
async def api_get_market_barometer():
    return get_market_barometer(data_fetcher)

# --- Rewolucja AI i Zarządzanie Dream Team ---
@app.post("/api/run_revolution", response_model=Dict)
async def api_run_revolution():
    scan_results = run_market_scan(data_fetcher)
    # Zgodnie z naprawionym `selection_agent`, `candidates` to już lista słowników
    portfolio_manager.update_dream_team(scan_results['candidates'])
    return scan_results

# NAPRAWIONO: Dodano brakujący endpoint wymagany przez frontend
@app.get("/api/portfolio/dream_team", response_model=List[Dict])
async def api_get_dream_team():
    return portfolio_manager.get_dream_team()

# --- Szybka i Złota Liga ---
@app.get("/api/scan_quick_league", response_model=List[Dict])
async def api_scan_quick_league():
    tickers = portfolio_manager.get_dream_team_tickers()
    if not tickers:
        return []
    return run_quick_league_scan(tickers, data_fetcher)

@app.get("/api/analyze_golden_league", response_model=List[Dict])
async def api_analyze_golden_league():
    tickers = portfolio_manager.get_dream_team_tickers()
    if not tickers:
        return []
    return run_zlota_liga_analysis(tickers, data_fetcher)

# --- Kokpit, Portfel i Ryzyko ---
@app.get("/api/cockpit_data", response_model=Dict)
async def api_get_cockpit_data():
    return analyze_cockpit_data(portfolio_manager.get_closed_positions())

@app.get("/api/portfolio_state", response_model=Dict)
async def api_get_portfolio_state():
    return portfolio_manager.get_full_portfolio_state()

# NAPRAWIONO: Dodano brakujący endpoint do analizy ryzyka portfela
@app.get("/api/portfolio_risk", response_model=Dict)
async def api_get_portfolio_risk():
    tickers = portfolio_manager.get_dream_team_tickers()
    return run_portfolio_risk_analysis(tickers, data_fetcher)

# --- Zarządzanie Pozycjami ---
@app.post("/api/open_position", response_model=Dict)
async def api_open_position(payload: PositionPayload):
    position = portfolio_manager.open_position(**payload.dict())
    return {"status": "success", "position": position}

@app.post("/api/close_position", response_model=Dict)
async def api_close_position(payload: ClosePositionPayload):
    closed_pos = portfolio_manager.close_position(payload.id, payload.closePrice)
    if not closed_pos:
        raise HTTPException(status_code=404, detail="Pozycja nie znaleziona.")
    return {"status": "success", "closedPosition": closed_pos}

# --- Backtesting ---
# NAPRAWIONO: Endpoint dostosowany do logiki frontendu (analiza jednego tickera)
@app.get("/api/run_backtest/{ticker}", response_model=Dict)
async def api_run_backtest(ticker: str, period: int = 365, risk_level: int = 2):
    # Uruchamia backtest dla jednego, konkretnego tickera
    trades = run_backtest([ticker], period, risk_level, data_fetcher)
    if not trades:
        return {"total_pnl": 0, "trade_count": 0, "trades": []}

    total_pnl = sum(trade.get('pnl', 0) for trade in trades)
    return {"total_pnl": round(total_pnl, 2), "trade_count": len(trades), "trades": trades}

# --- ULEPSZONO: Logika Centrum Decyzyjnego AI ---
def generate_ai_summary(indicators: Dict, risk: Dict) -> Dict:
    """Prosty agent decyzyjny na podstawie wskaźników i ryzyka."""
    score = 0
    reasons = []

    # Ocena wskaźników
    if indicators.get('rsi', 50) < 40:
        score += 1
        reasons.append("Wskaźnik RSI jest na niskim poziomie, sugerując potencjalne odbicie.")
    if indicators.get('macd_hist', 0) > 0:
        score += 1
        reasons.append("Histogram MACD jest dodatni, co wskazuje na rosnący impet.")
    if indicators.get('stoch_k', 50) < 30:
        score += 1
        reasons.append("Oscylator stochastyczny w strefie wyprzedania.")

    # Ocena ryzyka
    if risk.get('riskLevel') == 'Niskie':
        score += 1
        reasons.append("Niskie ryzyko (Beta i korelacja) w porównaniu do rynku.")

    if score >= 3:
        return {"recommendation": "SYGNAŁ KUPNA", "justification": " ".join(reasons)}
    if score >= 2:
        return {"recommendation": "Obserwuj", "justification": "Pojawiają się pozytywne sygnały, ale wymagają potwierdzenia."}
    return {"recommendation": "Unikaj / Trzymaj", "justification": "Brak wystarczających sygnałów do zajęcia pozycji."}

# --- Analiza 360 Stopni ---
# NAPRAWIONO: Całkowicie przebudowany endpoint, aby dostarczał dane wymagane przez frontend
@app.get("/api/full_analysis/{ticker}", response_model=Dict)
async def api_full_analysis(ticker: str):
    """
    Przebudowany endpoint do pełnej analizy 360 stopni.
    """
    overview_data = data_fetcher.get_data({"function": "OVERVIEW", "symbol": ticker})
    daily_data_json = data_fetcher.get_data({"function": "TIME_SERIES_DAILY", "symbol": ticker, "outputsize": "full"})
    quote_data = data_fetcher.get_data({"function": "GLOBAL_QUOTE", "symbol": ticker})
    qqq_daily_json = data_fetcher.get_data({"function": "TIME_SERIES_DAILY", "symbol": "QQQ", "outputsize": "compact"})

    if not all([overview_data, daily_data_json, quote_data, qqq_daily_json]):
        raise HTTPException(status_code=404, detail=f"Brak kluczowych danych dla {ticker}.")

    stock_df = transform_to_dataframe(daily_data_json)
    market_df = transform_to_dataframe(qqq_daily_json)
    if stock_df is None or market_df is None:
        raise HTTPException(status_code=500, detail="Błąd przetwarzania danych historycznych.")

    stock_df.ta.rsi(length=14, append=True)
    stock_df.ta.macd(fast=12, slow=26, signal=9, append=True)
    stock_df.ta.bbands(length=20, append=True)
    stock_df.ta.stoch(k=14, d=3, smooth_k=3, append=True)

    latest_indicators = stock_df.iloc[-1].to_dict()
    risk_analysis = analyze_single_stock_risk(stock_df, market_df, overview_data)
    ai_summary = generate_ai_summary(latest_indicators, risk_analysis)

    # Połączenie danych z OVERVIEW i GLOBAL_QUOTE w jeden obiekt dla frontendu
    quote = quote_data.get("Global Quote", {})
    combined_overview = {
        "name": overview_data.get("Name"),
        "symbol": overview_data.get("Symbol"),
        "sector": overview_data.get("Sector"),
        "description": overview_data.get("Description"),
        "price": float(quote.get("05. price", 0)),
        "change": float(quote.get("09. change", 0)),
        "changePercent": float(quote.get("10. change percent", "0%").replace('%', ''))
    }

    return {
        "overview": combined_overview,
        "risk": risk_analysis,
        "aiSummary": ai_summary,
        "daily": daily_data_json, # Surowe dane dla wykresów
        "indicators": {
            "rsi": latest_indicators.get('RSI_14'),
            "macd_line": latest_indicators.get('MACD_12_26_9'),
            "macd_signal": latest_indicators.get('MACDs_12_26_9'),
            "macd_hist": latest_indicators.get('MACDh_12_26_9'),
            "bbands_upper": latest_indicators.get('BBU_20_2.0'),
            "bbands_lower": latest_indicators.get('BBL_20_2.0'),
            "stoch_k": latest_indicators.get('STOCHk_14_3_3'),
        }
    }

# --- Uruchomienie Serwera ---
if __name__ == "__main__":
    # Render użyje zmiennej PORT; 8000 to fallback dla lokalnego rozwoju
    port = int(os.environ.get("PORT", 8000))
    # reload=True jest przydatne w deweloperce, gunicorn zajmie się tym w produkcji
    uvicorn.run("main:app", host="0.0.0.0", port=port, reload=True)