# -*- coding: utf-8 -*-
"""Uzupełniony Menedżer Portfela

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10qpRsD0EsiTHrMy7UdjFXrE403KObMY8
"""

"""
Moduł Menedżera Portfela.

Odpowiedzialność: Zarządzanie stanem portfela użytkownika, w tym listą
obserwowanych spółek (Dream Team) oraz otwartymi i zamkniętymi pozycjami.
"""

from datetime import datetime
import uuid
# Ulepszono: Dodano type hinting dla czytelności i bezpieczeństwa.
from typing import List, Dict, Any, Optional

class PortfolioManager:
    def __init__(self):
        """
        Inicjalizuje menedżera z pustymi listami.
        """
        self._dream_team: List[Dict[str, Any]] = []
        self._open_positions: List[Dict[str, Any]] = []
        self._closed_positions: List[Dict[str, Any]] = []
        print("[PortfolioManager] Menedżer portfela został zainicjowany.")

    # --- Zarządzanie Dream Team ---

    def get_dream_team(self) -> List[Dict[str, Any]]:
        """Zwraca listę spółek z "Dream Teamu"."""
        return self._dream_team

    # NAPRAWIONO: Dodano brakującą, kluczową metodę `get_dream_team_tickers`.
    # Jest ona niezbędna dla działania endpointów w `main.py`.
    def get_dream_team_tickers(self) -> List[str]:
        """
        Zwraca listę samych tickerów z "Dream Teamu".
        """
        # Ulepszono: Zabezpieczenie na wypadek, gdyby element na liście nie miał klucza 'ticker'.
        return [stock['ticker'] for stock in self._dream_team if 'ticker' in stock]

    def update_dream_team(self, new_candidates_list: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Aktualizuje Dream Team na podstawie wyników skanowania Rewolucji AI.
        """
        # Ulepszono: Dodano walidację typu wejściowego.
        if not isinstance(new_candidates_list, list):
            print("[PortfolioManager] BŁĄD: Oczekiwano listy kandydatów, otrzymano inny typ.")
            return self._dream_team

        self._dream_team = new_candidates_list
        tickers = self.get_dream_team_tickers()
        print(f"[PortfolioManager] Dream Team zaktualizowany. Nowi kandydaci: {tickers}")
        return self._dream_team

    def update_dream_team_prices(self, price_updates: Dict[str, Dict[str, float]]):
        """
        Metoda do hurtowej aktualizacji cen i danych w Dream Team.
        """
        updated_count = 0
        for stock in self._dream_team:
            if 'ticker' in stock and stock['ticker'] in price_updates:
                stock.update(price_updates[stock['ticker']])
                updated_count += 1
        print(f"[PortfolioManager] Zaktualizowano ceny dla {updated_count} spółek w Dream Team.")

    # --- Zarządzanie Transakcjami ---

    def open_position(self, ticker: str, quantity: int, entry_price: float, reason: str, target_price: float, stop_loss_price: float) -> Dict[str, Any]:
        """Dodaje nową otwartą pozycję."""
        position = {
            "id": str(uuid.uuid4()),
            "ticker": ticker,
            "quantity": quantity,
            "entryPrice": entry_price,
            "targetPrice": target_price,
            "stopLossPrice": stop_loss_price,
            "openDate": datetime.now().isoformat(),
            "status": "active",
            "reason": reason
        }
        self._open_positions.append(position)
        print(f"[PortfolioManager] Otwarto nową pozycję: {quantity} akcji {ticker} po cenie {entry_price}")
        return position

    def close_position(self, position_id: str, close_price: float) -> Optional[Dict[str, Any]]:
        """Zamyka otwartą pozycję i przenosi ją do historii."""
        position_to_close = next((p for p in self._open_positions if p.get('id') == position_id), None)

        if not position_to_close:
            print(f"[PortfolioManager] BŁĄD: Nie znaleziono otwartej pozycji o ID: {position_id}")
            return None

        self._open_positions = [p for p in self._open_positions if p.get('id') != position_id]

        closed_position = position_to_close
        closed_position['closePrice'] = close_price
        closed_position['closeDate'] = datetime.now().isoformat()
        closed_position['status'] = 'closed'

        entry_price = closed_position.get('entryPrice', 0)
        quantity = closed_position.get('quantity', 0)

        pnl = (close_price - entry_price) * quantity
        pnl_percent = ((close_price / entry_price) - 1) * 100 if entry_price != 0 else 0

        closed_position['pnl'] = round(pnl, 2)
        closed_position['pnlPercent'] = round(pnl_percent, 2)

        self._closed_positions.append(closed_position)
        print(f"[PortfolioManager] Zamknięto pozycję dla {closed_position.get('ticker')}. Zysk/Strata: {pnl:.2f}$")
        return closed_position

    # --- Dostęp do Danych ---

    def get_open_positions(self) -> List[Dict[str, Any]]:
        return self._open_positions

    def get_closed_positions(self) -> List[Dict[str, Any]]:
        return self._closed_positions

    def get_full_portfolio_state(self) -> Dict[str, List[Dict[str, Any]]]:
        """Zwraca kompletny stan portfela dla API."""
        return {
            "dreamTeam": self.get_dream_team(),
            "openPositions": self.get_open_positions(),
            "closedPositions": self.get_closed_positions()
        }