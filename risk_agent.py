# -*- coding: utf-8 -*-
"""Ujednolicony Agent Ryzyka

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yYl_S8RURHDs35n-g6KfcXUANWKYO7o8
"""

"""
Moduł Agenta Ryzyka "Cerber".

Odpowiedzialność: Analiza ryzyka portfela (korelacja) oraz
ocena ryzyka pojedynczej spółki (Beta, korelacja z rynkiem).
"""
from typing import Dict, Optional, List, Any
import pandas as pd
from itertools import combinations
from data_fetcher import DataFetcher, transform_to_dataframe

def calculate_returns_correlation(data_a: Optional[pd.DataFrame], data_b: Optional[pd.DataFrame]) -> Optional[float]:
    """
    Oblicza korelację Pearsona dla dziennych stóp zwrotu dwóch serii danych.
    """
    if data_a is None or data_b is None or 'close' not in data_a.columns or 'close' not in data_b.columns:
        return None

    # Ulepszono: Upewniamy się, że oba DataFrame mają ten sam typ indeksu przed złączeniem.
    data_a.index = pd.to_datetime(data_a.index)
    data_b.index = pd.to_datetime(data_b.index)

    merged_data = pd.merge(data_a['close'], data_b['close'], left_index=True, right_index=True, how='inner', suffixes=('_a', '_b'))
    if len(merged_data) < 20:
        return None

    returns = merged_data.pct_change().dropna()
    if len(returns) < 2 or returns.iloc[:, 0].equals(returns.iloc[:, 1]):
        return 1.0 # Jeśli stopy zwrotu są identyczne, korelacja wynosi 1

    correlation = returns.iloc[:, 0].corr(returns.iloc[:, 1])
    return correlation if pd.notna(correlation) else None

# NAPRAWIONO: Zmieniono nazwę na bardziej generyczną i dodano pobieranie danych.
def run_portfolio_risk_analysis(tickers: List[str], data_fetcher: DataFetcher) -> Dict:
    """
    Pobiera dane dla tickerów z portfela i analizuje ryzyko korelacji.
    """
    if len(tickers) < 2:
        return {"correlation": 0.0, "level": "Brak Danych", "summary": "Portfel musi zawierać min. 2 aktywa.", "color": "text-gray-400"}

    portfolio_data: Dict[str, pd.DataFrame] = {}
    for ticker in tickers:
        daily_data = data_fetcher.get_data({"function": "TIME_SERIES_DAILY", "symbol": ticker, "outputsize": "compact"})
        df = transform_to_dataframe(daily_data)
        if df is not None:
            portfolio_data[ticker] = df

    if len(portfolio_data) < 2:
         return {"correlation": 0.0, "level": "Błąd Danych", "summary": "Nie udało się pobrać wystarczających danych.", "color": "text-red-500"}

    all_correlations = [
        c for c in (
            calculate_returns_correlation(portfolio_data.get(t_a), portfolio_data.get(t_b))
            for t_a, t_b in combinations(portfolio_data.keys(), 2)
        ) if c is not None
    ]

    if not all_correlations:
        return {"correlation": 0.0, "level": "Błąd Obliczeń", "summary": "Nie można obliczyć korelacji.", "color": "text-red-500"}

    avg_corr = sum(all_correlations) / len(all_correlations)

    level, color, summary = "Niski", "text-green-400", "Portfel jest dobrze zdywersyfikowany."
    if avg_corr > 0.7:
        level, color, summary = "Bardzo Wysoki", "text-red-500", "Ryzyko koncentracji jest bardzo wysokie!"
    elif avg_corr > 0.5:
        level, color, summary = "Wysoki", "text-yellow-500", "Podwyższone ryzyko koncentracji."
    elif avg_corr > 0.3:
        level, color, summary = "Umiarkowany", "text-blue-400", "Dywersyfikacja na umiarkowanym poziomie."

    return {"correlation": avg_corr, "level": level, "summary": summary, "color": color}

def analyze_single_stock_risk(stock_df: Optional[pd.DataFrame], market_df: Optional[pd.DataFrame], overview_data: Dict) -> Dict:
    """
    Analizuje ryzyko pojedynczej spółki.
    """
    if stock_df is None or market_df is None or overview_data is None:
        return {"beta": "N/A", "correlation": "N/A", "riskLevel": "Brak Danych", "riskColor": "text-gray-400"}

    beta_str = overview_data.get('Beta', 'N/A')
    correlation = calculate_returns_correlation(stock_df, market_df)

    risk_level, risk_color = 'N/A', 'text-gray-400'

    # Ulepszono: Bardziej odporna logika oceny ryzyka
    try:
        if beta_str != 'N/A' and correlation is not None:
            beta_f = float(beta_str)
            risk_score = 0
            if beta_f > 1.8: risk_score += 2
            elif beta_f > 1.2: risk_score += 1

            if correlation > 0.8: risk_score += 1

            if risk_score >= 2:
                risk_level, risk_color = 'Wysokie', 'text-red-400'
            elif risk_score >= 1:
                risk_level, risk_color = 'Umiarkowane', 'text-yellow-400'
            else:
                risk_level, risk_color = 'Niskie', 'text-green-400'
    except (ValueError, TypeError):
        risk_level, risk_color = 'Błąd Oceny', 'text-gray-400'


    return {
        "beta": beta_str,
        "correlation": f"{correlation:.2f}" if correlation is not None else "N/A",
        "riskLevel": risk_level,
        "riskColor": risk_color
    }