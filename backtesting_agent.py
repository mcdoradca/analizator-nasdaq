# -*- coding: utf-8 -*-
"""Naprawiony Agent Backtestingu

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/196yIMLr9_VoLfFOGp2ArE6XPYd80TBvZ
"""

"""
Moduł Silnika Backtestingu "Wehikuł Czasu".

Odpowiedzialność: Przeprowadzanie zaawansowanych symulacji historycznych
dla strategii "Szybkiej Ligi" na podstawie zdefiniowanych przez użytkownika
parametrów.
"""
from datetime import datetime, timedelta
import numpy as np
from typing import List, Dict, Any

# NAPRAWIONO: Import dostosowany do rzeczywistej zawartości modułu szybka_liga_agent.
# Usunięto import nieistniejącego 'agent_sygnalu'.
from szybka_liga_agent import agent_korekty_fibonacciego, agent_potwierdzenia, agent_historyczny
from utils import safe_float

# --- Funkcje Pomocnicze do Obliczania Wskaźników ---
# Te funkcje muszą być tutaj, aby symulować wskaźniki na danych historycznych

def calculate_sma(series: List[float], period: int) -> float | None:
    if len(series) < period: return None
    return sum(series[-period:]) / period

def calculate_bbands(series: List[float], period: int = 20, nbdev: int = 2) -> Dict[str, float] | None:
    if len(series) < period: return None
    sma = calculate_sma(series, period)
    if sma is None: return None
    std_dev = np.std(series[-period:])
    return {
        'Real Lower Band': sma - (nbdev * std_dev),
        'Real Upper Band': sma + (nbdev * std_dev)
    }

def calculate_rsi(series: List[float], period: int = 14) -> float | None:
    if len(series) < period + 1: return None
    deltas = np.diff(series)
    gains = deltas[deltas > 0]
    losses = -deltas[deltas < 0]

    # Unikamy dzielenia przez zero i obsługujemy przypadki braku zysków/strat
    avg_gain = np.mean(gains[-period:]) if len(gains) > 0 else 0
    avg_loss = np.mean(losses[-period:]) if len(losses) > 0 else 1e-10 # Unikamy dzielenia przez zero

    rs = avg_gain / avg_loss
    return 100 - (100 / (1 + rs))

def calculate_stoch(historical_slice: List[Dict[str, float]], period: int = 14) -> float | None:
    if len(historical_slice) < period: return None

    highs = [d.get('2high', 0) for d in historical_slice]
    lows = [d.get('3low', 0) for d in historical_slice]
    closes = [d.get('4close', 0) for d in historical_slice]

    l14 = min(lows[-period:])
    h14 = max(highs[-period:])

    range_14 = h14 - l14
    if range_14 == 0: return 0

    slow_k = ((closes[-1] - l14) / range_14) * 100
    return slow_k

# --- Główny Silnik Backtestingu ---

def run_backtest(tickers: List[str], period_days: int, risk_level: int, data_fetcher: Any) -> List[Dict[str, Any]]:
    """
    Uruchamia pełny backtest dla strategii "Szybkiej Ligi".
    """
    print(f"[Wehikuł Czasu] Rozpoczynam backtest dla {len(tickers)} spółek, okres: {period_days} dni, ryzyko: {risk_level}.")
    all_trades = []
    end_date = datetime.now()

    for ticker in tickers:
        try:
            full_daily_data = data_fetcher.get_data({
                "function": "TIME_SERIES_DAILY", "symbol": ticker, "outputsize": "full"
            })
            if not full_daily_data or 'Time Series (Daily)' not in full_daily_data:
                continue

            series = sorted(
                [(k, {k.replace('. ', ''): safe_float(v) for k, v in val.items()}) for k, val in full_daily_data['Time Series (Daily)'].items()],
                key=lambda item: datetime.strptime(item[0], '%Y-%m-%d')
            )

            # Wymagamy minimum 90 dni danych historycznych do rozpoczęcia symulacji
            if len(series) < 90: continue

            for i in range(90, len(series)):
                current_date_str, _ = series[i]
                current_date = datetime.strptime(current_date_str, '%Y-%m-%d')

                if current_date < (end_date - timedelta(days=period_days)):
                    continue

                historical_slice_data = [s[1] for s in series[:i+1]]
                historical_slice_dict = dict(series[:i+1])
                mock_daily_data = {'Time Series (Daily)': historical_slice_dict}

                # Symulacja obliczeń wskaźników na danych historycznych
                close_prices = [s.get('4close', 0) for s in historical_slice_data]
                mock_rsi_data = {'Technical Analysis: RSI': {current_date_str: {'RSI': calculate_rsi(close_prices)}}}
                mock_stoch_data = {'Technical Analysis: STOCH': {current_date_str: {'SlowK': calculate_stoch(historical_slice_data)}}}

                # NAPRAWIONO: Użycie właściwego agenta `agent_korekty_fibonacciego` zamiast nieistniejącego `agent_sygnalu`.
                signal_result = agent_korekty_fibonacciego(mock_daily_data)

                if signal_result.get('signal'):
                    confirmation_score = agent_potwierdzenia(mock_rsi_data, mock_stoch_data)
                    history_result = agent_historyczny(mock_daily_data)
                    total_score = 1 + confirmation_score + history_result['historyScore']

                    if total_score >= risk_level:
                        # NAPRAWIONO: Poprawne odczytanie danych zagnieżdżonych w 'plan'.
                        entry_price = signal_result.get('entry')
                        stop_loss = signal_result.get('plan', {}).get('stopLoss')
                        target_price = signal_result.get('plan', {}).get('target')

                        if not all([entry_price, stop_loss, target_price]): continue

                        # Symulacja przyszłości w celu zamknięcia transakcji
                        for j in range(i + 1, min(i + 30, len(series))): # Sprawdzamy do 30 dni w przód
                            future_date_str, future_day_data = series[j]
                            future_low = future_day_data.get('3low', 0)
                            future_high = future_day_data.get('2high', 0)

                            if future_low <= stop_loss:
                                all_trades.append({
                                    'ticker': ticker, 'pnl': stop_loss - entry_price,
                                    'openDate': current_date_str, 'closeDate': future_date_str, 'outcome': 'StopLoss'
                                })
                                break

                            if future_high >= target_price:
                                all_trades.append({
                                    'ticker': ticker, 'pnl': target_price - entry_price,
                                    'openDate': current_date_str, 'closeDate': future_date_str, 'outcome': 'Target'
                                })
                                break

        except Exception as e:
            print(f"[Wehikuł Czasu] Błąd podczas symulacji dla {ticker}: {e}")

    print(f"[Wehikuł Czasu] Backtest zakończony. Zasymulowano {len(all_trades)} transakcji.")
    if not all_trades: return []
    return sorted(all_trades, key=lambda x: datetime.strptime(x['closeDate'], '%Y-%m-%d'))